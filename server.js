const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const morgan = require('morgan');
const path = require('path');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(helmet({
    contentSecurityPolicy: false, // –û—Ç–∫–ª—é—á–∞–µ–º –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
}));
app.use(compression());
app.use(morgan('combined'));
app.use(cors());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ñ–∞–π–ª—ã
app.use(express.static(path.join(__dirname, 'public')));

// –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ MongoDB
const MONGO_URI = process.env.MONGO_URI || 'mongodb://localhost:27017/bifo';

mongoose.connect(MONGO_URI)
  .then(() => {
    console.log('‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ MongoDB —É—Å–ø–µ—à–Ω–æ');
  })
  .catch((error) => {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ MongoDB:', error);
    process.exit(1);
  });

// –ò–º–ø–æ—Ä—Ç –º–æ–¥–µ–ª–µ–π
const Product = require('./models/Product');
const Category = require('./models/Category');

// API Routes
app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    message: 'BIFO API —Ä–∞–±–æ—Ç–∞–µ—Ç', 
    timestamp: new Date().toISOString() 
  });
});

// –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–æ–≤ —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π –∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π
app.get('/api/products', async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const category = req.query.category;
    const search = req.query.search;
    const minPrice = req.query.minPrice;
    const maxPrice = req.query.maxPrice;
    const vendor = req.query.vendor;
    const sort = req.query.sort || 'createdAt';

    // –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ —Ñ–∏–ª—å—Ç—Ä–∞
    const filter = {};
    
    if (category) {
      filter['section.title'] = new RegExp(category, 'i');
    }
    
    if (search) {
      filter.$or = [
        { title: new RegExp(search, 'i') },
        { 'techShortSpecifications': new RegExp(search, 'i') }
      ];
    }
    
    if (minPrice || maxPrice) {
      filter.currentPrice = {};
      if (minPrice) filter.currentPrice.$gte = parseInt(minPrice);
      if (maxPrice) filter.currentPrice.$lte = parseInt(maxPrice);
    }
    
    if (vendor) {
      filter['vendor.title'] = new RegExp(vendor, 'i');
    }

    // –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏
    let sortObj = {};
    switch (sort) {
      case 'price_asc':
        sortObj = { currentPrice: 1 };
        break;
      case 'price_desc':
        sortObj = { currentPrice: -1 };
        break;
      case 'popular':
        sortObj = { salesCount: -1 };
        break;
      case 'newest':
        sortObj = { createdAt: -1 };
        break;
      default:
        sortObj = { createdAt: -1 };
    }

    // –ü–æ–¥—Å—á–µ—Ç –æ–±—â–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Ç–æ–≤–∞—Ä–æ–≤
    const totalItems = await Product.countDocuments(filter);
    const totalPages = Math.ceil(totalItems / limit);
    const skip = (page - 1) * limit;

    // –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–æ–≤
    const products = await Product.find(filter)
      .sort(sortObj)
      .skip(skip)
      .limit(limit)
      .lean();
    
    res.json({
      products: products,
      pagination: {
        currentPage: page,
        totalPages: totalPages,
        totalItems: totalItems,
        hasNext: page < totalPages,
        hasPrev: page > 1
      }
    });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–≤–∞—Ä–æ–≤:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  }
});

// –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç–æ–≤–∞—Ä–∞
app.get('/api/products/:id', async (req, res) => {
  try {
    const product = await Product.findOne({ id: parseInt(req.params.id) });
    if (!product) {
      return res.status(404).json({ error: '–¢–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω' });
    }
    res.json(product);
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–≤–∞—Ä–∞:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  }
});

// –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª–µ–π
app.get('/api/vendors', async (req, res) => {
  try {
    const vendors = await Product.distinct('vendor.title');
    res.json(vendors.filter(vendor => vendor).sort());
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª–µ–π:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  }
});

// –ü–æ–ª—É—á–µ–Ω–∏–µ —Ü–µ–Ω–æ–≤–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞
app.get('/api/price-range', async (req, res) => {
  try {
    const priceRange = await Product.aggregate([
      {
        $group: {
          _id: null,
          minPrice: { $min: '$currentPrice' },
          maxPrice: { $max: '$currentPrice' }
        }
      }
    ]);

    if (priceRange.length > 0) {
      res.json({
        min: priceRange[0].minPrice,
        max: priceRange[0].maxPrice
      });
    } else {
      res.json({ min: 0, max: 0 });
    }
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–µ–Ω–æ–≤–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  }
});

// –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π
app.get('/api/categories', async (req, res) => {
  try {
    const categories = await Category.find({ isActive: true })
      .sort({ group: 1, order: 1 })
      .lean();
    
    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ –≥—Ä—É–ø–ø–∞–º
    const groupedCategories = categories.reduce((acc, category) => {
      if (!acc[category.group]) {
        acc[category.group] = [];
      }
      acc[category.group].push(category);
      return acc;
    }, {});

    res.json(groupedCategories);
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  }
});

// –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –≥—Ä—É–ø–ø—ã
app.get('/api/categories/:group', async (req, res) => {
  try {
    const categories = await Category.find({ 
      group: req.params.group,
      isActive: true 
    })
    .sort({ order: 1 })
    .lean();
    
    res.json(categories);
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π –≥—Ä—É–ø–ø—ã:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  }
});

// –ü–æ–∏—Å–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π
app.get('/api/categories/search/:query', async (req, res) => {
  try {
    const query = req.params.query;
    const categories = await Category.find({
      $text: { $search: query },
      isActive: true
    })
    .sort({ score: { $meta: 'textScore' } })
    .limit(10)
    .lean();
    
    res.json(categories);
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–π:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  }
});

// –ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// –°—Ç—Ä–∞–Ω–∏—Ü–∞ –∫–∞—Ç–∞–ª–æ–≥–∞
app.get('/catalog', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'catalog.html'));
});

// –°—Ç—Ä–∞–Ω–∏—Ü–∞ —Ç–æ–≤–∞—Ä–∞
app.get('/product/:id', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'product.html'));
});

// 404 –¥–ª—è –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –º–∞—Ä—à—Ä—É—Ç–æ–≤
app.use('*', (req, res) => {
  res.status(404).json({ error: '–°—Ç—Ä–∞–Ω–∏—Ü–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞' });
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
app.use((error, req, res, next) => {
  console.error('–ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞:', error);
  res.status(500).json({ error: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
});

// –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
app.listen(PORT, () => {
  console.log(`üöÄ BIFO —Å–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É ${PORT}`);
  console.log(`üåê http://localhost:${PORT}`);
});

module.exports = app; 